---
layout: single
title: (핵심만 쏙!) 객체 지향 소프트웨어 설계(디자인)하기
categories:
  - Flutter
tags:
  - [Object-Oriented-Design]
toc: true
date: 2024-01-13
---

오늘은 소프트웨어를 설계할 때 적용할 수 있는 객체 지향 설계에 관한 글이다. 

## 👀TL;DR

- 바로 구현 작업을 하는 것은 프로젝트 실패의 주원인이 될 수 있다.
- 프로젝트를 실패하지 않으려면 요구사항을 만들고 소프트웨어를 설계하는 데 시간을 들여야 한다.
- 크게는 개념적 설계, 기술적 설계로 나눌 수 있는데,
    - 개념적 설계는 1) 구성 요소 식별 2) 구성 요소 간 연결 3) 구성 요소의 책임 식별 로 진행된다.
    - 기술적 설계는 위 단계를 더 이상 분해될 수 없을 때까지 구성 요소를 식별한 후 이를 속성(Attribute), 메서드(Method)로 구현한다.
- **객체 지향 설계**란, 현실을 객체의 관점에서 바라보고 이를 컴퓨터의 언어로 모델링하는 작업이다.
- **요구 사항**은 **사용자 스토리**로 표현할 수 있다.
    - 사용자 스토리: As a ______, I want to _______ so that_______ 형태를 띈다.
        - As a ______ : 해당 빈칸에는 요구 사항을 원하는 사용자를 적는다.(user role로 칭함.)
        - I want to ______: 위에서 적은 사용자가 무엇을 이루고 싶어하는 지를 적는다.
        - so that ______: 왜 이루고 싶어하는 지를 적는다.
        
        [ 예시 ]
        
        As a online shopper, I want to add item to shopping cart so that I purchase that.
        
        - 주로 **명사**는 **객체로 식별**한다. (온라인 쇼핑하는 사람, 장바구니, 물건)
        - 주로 **동사**는 객체의 **책임**을 의미한다. (add, purchase)
            - 그리고 객체 간 연결을 정의하는 데 도움이 된다.(온라인 쇼핑하는 사람이 장바구니에 물건을 추가한다.)
                - 한 사람은 하나의 장바구니를 이용한다.
                
                - 한 사람은 여러 개의 물건을 살 수 있다.
- 이렇게 요구 사항에서 객체와 객체의 책임, 객체 간 관계를 추출했다면 CRC 카드를 이용하자.
- **CRC 카드**란? Class name, Responsibility, Collaborator 의 약어로 다음과 같은 형태를 띄고 있다.
    
    ![CRC 카드](https://github.com/changhwan77/changhwan77.github.io/assets/110464205/536fe1da-fba3-4597-a777-3acdfd892121)

    1. 요구 사항에서 추출한 객체를 **Class name에 작성**하자.
    2. **책임**도 마찬가지다.
    3. **Collaborator**는 해당 객체가 책임을 수행하기 위해 상호 작용하는 객체를 일컫는다. 
    4. 그렇게 카드가 만들어졌다면 해결하려는 실생활의 문제를 **시나리오 별로 나누고 실제 시뮬레이션을 해보며 추가적인 객체를 식별하고 다른 가능성을 탐구**한다.
    5. 그렇게 더 이상 나올 객체가 없다면 마무리한다.
- 이렇게 하면 개념적 설계가 끝나고 기술적 설계로 넘어간다. 즉, Class.(속성과 행동)를 정의한다.
- 이 때 **객체 지향 설계의 원칙 4가지**를 적용한다.
    - **추상화**: Class를 정의할 때 특정한 맥락(context)에서 꼭 필요한 속성과 행동(behavior)를 정의.
    - **캡슐화**
        - bundle: 클래스에 필요한 데이터와 이 데이터를 사용할 메서드를 묶는 것을 의미한다.
        - expose: 외부에서 접근할 수 있도록 외부에 노출 시킬 클래스의 메서드를 정한다.
        - restrict: 외부에서 접근할 수 없도록 클래스의 속성과 메서드를 정의한다.
    - **분해**(Decomposition): 전체 객체를 부분으로 나눈다. 이 때는 3가지 관점을 고려한다.
        - fixed, dynamic number: 전체와 비교했을 때 부분의 개수가 고정적인지 가변적인지 고려.
            - 예를 들어 자동차를 생각해보자. 운전 핸들은 개수가 1개로 고정적이지만 탑승객의 수는 변한다.
        - lifetime: 전체와 수명주기가 같은지 다른지를 고려.
        - share: 부분 또는 전체와 공유되는 부분이 있는지 고려.
    - **일반화**: 공통되는 속성이나 행동을 하나의 코드 덩어리로 묶음으로써 재사용가능하게 만들어 추가 코드 작성을 줄이는 것.
        - 대표적인 예로 **상속**(Inheritance)을 들 수 있다.
            - 즉, 두 개 이상의 클래스 간에 1) 반복되거나 2) 공유되거나 3) 공통되는 속성과 행동들을 묶어서 다른 하나의 클래스로 만든다.
            - 이를 부모(Super) 클래스라고 칭하고 부모 클래스의 속성과 행동을 물려받는 클래스를 자식(sub) 클래스라고 칭한다.
